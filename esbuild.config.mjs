import builtins from "builtin-modules"
import dotenv from "dotenv"
import esbuild from "esbuild"
import { watch } from "fs"
import fs from "fs/promises"
import { glob } from "glob"
import path from "path"
import process from "process"
import { fileURLToPath } from "url"

// Load environment variables
dotenv.config()

const __dirname = fileURLToPath(new URL(".", import.meta.url))

// Read plugin ID from manifest.json
async function getPluginId() {
  const manifestPath = path.join(__dirname, "manifest.json")
  const manifestContent = await fs.readFile(manifestPath, "utf8")
  const manifest = JSON.parse(manifestContent)
  return manifest.id
}

// Detect build modes
const prod = process.argv[2] === "production"
const isReleaseBuild = process.env.RELEASE_BUILD === "true"

// Determine output directory
async function getOutputDir() {
  if (isReleaseBuild) {
    return path.join(__dirname, "build")
  }

  const vaultPath = process.env.VAULT_PATH
  if (!vaultPath) {
    console.error("Error: VAULT_PATH environment variable is not set")
    console.error("Please create a .env file with VAULT_PATH=/path/to/your/vault")
    console.error("\nFor CI/CD builds, set RELEASE_BUILD=true to build to ./build directory")
    process.exit(1)
  }

  const pluginId = await getPluginId()
  return path.join(vaultPath, ".obsidian", "plugins", pluginId)
}

const outDir = await getOutputDir()

if (isReleaseBuild) {
  console.info("Building for release to ./build directory")
} else {
  console.info(`Building to vault plugin directory: ${outDir}`)
}

// Bundle all CSS files into one
async function bundleCssFiles() {
  try {
    // Find all CSS files in src directory
    const cssFiles = glob
      .sync("src/**/*.css")
      .filter(file => file !== "src/styles.css")

    // Start with the main styles.css content if it exists
    let mainCssContent = ""
    try {
      mainCssContent = await fs.readFile("src/styles.css", "utf8")
      mainCssContent += "\n\n/* Auto-collected component and view styles */\n"
    } catch (error) {
      // No main styles.css, create a header
      mainCssContent = "/* Auto-collected CSS */\n\n"
    }

    // Add each component/view CSS file content
    for (const file of cssFiles) {
      const componentName = path.basename(file, ".css")
      const fileContent = await fs.readFile(file, "utf8")

      // Add a comment to identify the source
      mainCssContent += `\n/* Styles from ${file} */\n`
      mainCssContent += fileContent
      mainCssContent += "\n"
    }

    // Write the bundled CSS to the output directory
    await fs.writeFile(path.join(outDir, "styles.css"), mainCssContent)

    console.info("CSS files bundled successfully")
  } catch (error) {
    console.error("Error bundling CSS files:", error)
  }
}

// Copy additional plugin files
async function copyPluginFiles() {
  try {
    // Create the directory if it doesn't exist
    await fs.mkdir(outDir, { recursive: true })

    // Copy manifest.json from root
    await fs.copyFile("manifest.json", path.join(outDir, "manifest.json"))

    // Bundle CSS files
    await bundleCssFiles()

    console.info("Plugin files copied successfully")
  } catch (error) {
    console.error("Error copying plugin files:", error)
  }
}

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: path.join(outDir, "main.js"),
  minify: prod,
  alias: {
    "@": path.resolve(__dirname, "src"),
  },
})

if (prod) {
  await context.rebuild()
  await copyPluginFiles()
  process.exit(0)
} else {
  // Initial copy of plugin files
  await copyPluginFiles()

  // Set up file watcher for the src directory (CSS files)
  const srcWatcher = watch(
    "src",
    { recursive: true },
    async (eventType, filename) => {
      if (filename && filename.endsWith(".css")) {
        // Re-bundle CSS whenever any CSS file changes
        await bundleCssFiles()
      }
    }
  )

  // Set up file watcher for manifest.json at root
  const manifestWatcher = watch(
    "manifest.json",
    async () => {
      await copyPluginFiles()
    }
  )

  // Handle cleanup on process termination
  process.on("SIGINT", () => {
    srcWatcher.close()
    manifestWatcher.close()
    context.dispose()
    process.exit(0)
  })

  // Start the watch mode
  await context.watch()
}
